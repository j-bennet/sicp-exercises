#lang scheme
;Exercise 1.9.  Each of the following two procedures defines a method for adding two positive integers in terms of the procedures inc, which increments its argument by 1, and dec, which decrements its argument by 1.
;
;
;(define (+ a b)
;  (if (= a 0)
;      b
;      (inc (+ (dec a) b))))
;
;(define (+ a b)
;  (if (= a 0)
;      b
;      (+ (dec a) (inc b))))
;
;Using the substitution model, illustrate the process generated by each procedure in evaluating (+ 4 5). Are these processes iterative or recursive?

; 1. recursively does into +, until a == 0, then returns with b (5), adds 1 (4 times)
; 2. recursively goes into +, until a == 0, then returns with b (9) - iterative
;
;Exercise 1.10.  The following procedure computes a mathematical function called Ackermann's function.

(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1)
                 (A x (- y 1))))))

;What are the values of the following expressions?
;
;(A 1 10) =  1024
;
;(A 2 4) = 65536
;
;(A 3 3) = 65536

(define (f n) (A 0 n))

(define (g n) (A 1 n))

(define (h n) (A 2 n))

(define (k n) (* 5 n n))

; (f n) = 2 * n
; (g n) = 2 ^ n
; (h n) = ?

; Exercise 1.11.  A function f is defined by the rule that 
; f(n) = n if n < 3
; f(n) = f(n - 1) + 2f(n - 2) + 3f(n - 3) if n > 3
; Write a procedure that computes f by means of a recursive process.

; recursive
(define (f1-11-r n)
  (if (< n 3)
      n
      (+ (f1-11-r (- n 1))
         (* 2 (f1-11-r (- n 2)))
         (* 3 (f1-11-r (- n 3))))))

; Write a procedure that computes f by means of an iterative process.

;???

; Exercise 1.12.  The following pattern of numbers is called Pascal's triangle.
;
; The numbers at the edge of the triangle are all 1, and each number inside the 
; triangle is the sum of the two numbers above it.
; Write a procedure that computes elements of Pascal's triangle by means of a
; recursive process.
(define (pascal r c)
  (cond ((= c 0) 1)
        ((= r 0) 1)
        ((= r c) 1)
        (#t (+ (pascal (- r 1) (- c 1)) (pascal (- r 1) c)))))

(define (pascal-test r c n)
  (cond ((or (< c r) (= c r))
         (begin
           (printf "~v " (pascal r c))
           (pascal-test r (+ c 1) n)))
        ((< r n)
         (begin
           (printf "\n")
           (pascal-test (+ r 1) 0 n)))))

; Exercise 1.16.  Design a procedure that evolves an iterative exponentiation process 
; that uses successive squaring and uses a logarithmic number of steps, as does fast-expt. 
; (Hint: Using the observation that (bn/2)2 = (b2)n/2, keep, along with the exponent n 
; and the base b, an additional state variable a, and define the state transformation 
; in such a way that the product a bn is unchanged from state to state. At the beginning
; of the process a is taken to be 1, and the answer is given by the value of a at the
; end of the process. In general, the technique of defining an invariant quantity
; that remains unchanged from state to state is a powerful way to think about
; the design of iterative algorithms.)

(define (even? n)
  (= (remainder n 2) 0))

(define (square x)
  (* x x))

(define (expt-iter-f b i product)
  (if (= i 0)
      product
      (if (even? i)
          (square (expt-iter-f b (/ i 2) product))
          (* b (expt-iter-f b (- i 1) product)))))

; Exercise 1.20.  The process that a procedure generates is of course dependent on the 
; rules used by the interpreter. As an example, consider the iterative gcd procedure 
; given above. Suppose we were to interpret this procedure using normal-order 
; evaluation, as discussed in section 1.1.5. (The normal-order-evaluation rule for if 
; is described in exercise 1.5.) Using the substitution method (for normal order), 
; illustrate the process generated in evaluating (gcd 206 40) and indicate the 
; remainder operations that are actually performed. How many remainder operations 
; are actually performed in the normal-order evaluation of (gcd 206 40)? In the 
; applicative-order evaluation?

(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))

; applicative order:
; (gcd 206 40) *
; (gcd 40 6)   *
; (gcd 6 4)    *
; (gcd 4 2)    *
; (gcd 2 0)
; 2
; = 4 remainder operations

; normal-order:
; (gcd 206 40)
; (gcd 40 (remainder 206 40))
; (gcd (remainder 206 40) (remainder 40 (remainder 206 40)))
; ... => (2 remainders, 4 remainders)
; ... => (4 remainders, 7 remainders)
; ... => (7 remainders, 12 remainders)
; 2
; = 19 remainder operations

(define (smallest-divisor n)
  (find-divisor n 2))

(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (next test-divisor)))))

(define (divides? a b)
  (= (remainder b a) 0))

(define (next n)
  (if (= n 2)
      3
      (+ n 2)))

;Exercise 1.21.  Use the smallest-divisor procedure to find the smallest divisor of each of the following numbers:
; 199 (199)
; 1999 (1999)
; 19999 (7)

(define (prime? n)
  (= n (smallest-divisor n)))

; Exercise 1.22.  Most Lisp implementations include a primitive called runtime that returns 
; an integer that specifies the amount of time the system has been running (measured, for 
; example, in microseconds). The following timed-prime-test procedure, when called with an 
; integer n, prints n and checks to see if n is prime. If n is prime, the procedure prints 
; three asterisks followed by the amount of time used in performing the test.

(define (timed-prime-test n)
  (start-prime-test n (current-milliseconds)))

(define (start-prime-test n start-time)
  (when (fast-prime? n 3)
      (newline)
      (display n)
      (report-prime (- (current-milliseconds) start-time))))

(define (report-prime elapsed-time)
  (display " *** ")
  (display elapsed-time))

; Using this procedure, write a procedure search-for-primes that checks the primality of 
; consecutive odd integers in a specified range. Use your procedure to find the three smallest 
; primes larger than 1000; larger than 10,000; larger than 100,000; larger than 1,000,000.

(define (search-for-primes start end)
  (when (< start end)
      (when (= (modulo start 2) 1)
        (timed-prime-test start))
      (search-for-primes (+ start 1) end)))

; Note the time needed to test each prime. Since the testing algorithm has order of growth 
; of (n), you should expect that testing for primes around 10,000 should take about 10 times 
; as long as testing for primes around 1000. Do your timing data bear this out? How well do 
; the data for 100,000 and 1,000,000 support the n prediction? Is your result compatible 
; with the notion that programs on your machine run in time proportional to the number of 
; steps required for the computation?

; Exercise 1.23.  The smallest-divisor procedure shown at the start of this section does 
; lots of needless testing: After it checks to see if the number is divisible by 2 there 
; is no point in checking to see if it is divisible by any larger even numbers. This suggests 
; that the values used for test-divisor should not be 2, 3, 4, 5, 6, ..., but rather 2, 
; 3, 5, 7, 9, .... To implement this change, define a procedure next that returns 3 if 
; its input is equal to 2 and otherwise returns its input plus 2. Modify the smallest-divisor
; procedure to use (next test-divisor) instead of (+ test-divisor 1). With
; timed-prime-test incorporating this modified version of smallest-divisor, run the test
; for each of the 12 primes found in exercise 1.22. Since this modification halves the
; number of test steps, you should expect it to run about twice as fast. Is this expectation
; confirmed? If not, what is the observed ratio of the speeds of the two algorithms, and how
; do you explain the fact that it is different from 2?

(define (expmod base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         (remainder (square (expmod base (/ exp 2) m))
                    m))
        (else
         (remainder (* base (expmod base (- exp 1) m))
                    m))))

(define (fermat-test n)
  (define (try-it a)
    (and
     (= (expmod a n n) a)
     (< (length (roots-of-unity n)) 3)))
  (try-it (+ 1 (random (- n 1)))))

(define (fast-prime? n times)
  (cond ((= times 0) true)
        ((fermat-test n) (fast-prime? n (- times 1)))
        (else false)))

; Exercise 1.24.  Modify the timed-prime-test procedure of exercise 1.22 to use fast-prime? 
; (the Fermat method), and test each of the 12 primes you found in that exercise. Since the Fermat 
; test has (log n) growth, how would you expect the time to test primes near 1,000,000 to 
; compare with the time needed to test primes near 1000? Do your data bear this out? 
; Can you explain any discrepancy you find?

; Exercise 1.25.  Alyssa P. Hacker complains that we went to a lot of extra work in writing expmod. 
; After all, she says, since we already know how to compute exponentials, we could have simply written

;(define (expmod base exp m)
;  (remainder (fast-expt base exp) m))

; Is she correct? Would this procedure serve as well for our fast prime tester? Explain.

; Exercise 1.26.  Louis Reasoner is having great difficulty doing exercise 1.24. His fast-prime? 
; test seems to run more slowly than his prime? test. Louis calls his friend Eva Lu Ator over 
; to help. When they examine Louis's code, they find that he has rewritten the expmod procedure 
; to use an explicit multiplication, rather than calling square:
;
;(define (expmod base exp m)
;  (cond ((= exp 0) 1)
;        ((even? exp)
;         (remainder (* (expmod base (/ exp 2) m)
;                       (expmod base (/ exp 2) m))
;                    m))
;        (else
;         (remainder (* base (expmod base (- exp 1) m))
;                    m))))
;
; ``I don't see what difference that could make,'' says Louis. ``I do.'' says Eva. 
; ``By writing the procedure like that, you have transformed the (log n) process into a (n) process.''
; Explain.

; Exercise 1.27.  Demonstrate that the Carmichael numbers listed in footnote 47 really do fool 
; the Fermat test. That is, write a procedure that takes an integer n and tests whether a^n is
; congruent to a modulo n for every a < n, and try your procedure on the given Carmichael numbers.
(define (congruent? a b n)
  (= (modulo a n) (modulo b n)))

(define (pass-fermat? n)
  (define (pass-fermat-iter? x a)
    (if (< a x)
        (if (congruent? (expt a n) (modulo a n) n)
            (pass-fermat-iter? x (+ a 1))
            #f)
        #t))
  (pass-fermat-iter? n 2))

; Exercise 1.28.  One variant of the Fermat test that cannot be fooled is called the Miller-Rabin
; test (Miller 1976; Rabin 1980). This starts from an alternate form of Fermat's Little Theorem,
; which states that if n is a prime number and a is any positive integer less than n, then a
; raised to the (n - 1)st power is congruent to 1 modulo n. To test the primality of a number
; n by the Miller-Rabin test, we pick a random number a<n and raise a to the (n - 1)st power
; modulo n using the expmod procedure. However, whenever we perform the squaring step in expmod,
; we check to see if we have discovered a ``nontrivial square root of 1 modulo n,'' that is, a
; number not equal to 1 or n - 1 whose square is congruent to 1 modulo n. It is possible to prove
; that if such a nontrivial square root of 1 exists, then n is not prime. It is also possible
; to prove that if n is an odd number that is not prime, then, for at least half the numbers a<n,
; computing an-1 in this way will reveal a nontrivial square root of 1 modulo n. (This is why
; the Miller-Rabin test cannot be fooled.) Modify the expmod procedure to signal if it discovers
; a nontrivial square root of 1, and use this to implement the Miller-Rabin test with a procedure
; analogous to fermat-test. Check your procedure by testing various known primes and non-primes.
; Hint: One convenient way to make expmod signal is to have it return 0.

(define (roots-of-unity n)
  (define (root-mod? i)
    (= (modulo (square i) n) 1))
  (define (roots-iter x xs)
    (if (< x n)
        (if (root-mod? x)
            (roots-iter (+ x 1) (cons x xs))
            (roots-iter (+ x 1) xs))
        xs))
  (roots-iter 1 empty))

; Numbers that fool the Fermat test are called Carmichael numbers, and little is known about them 
; other than that they are extremely rare. There are 255 Carmichael numbers below 100,000,000. 
; The smallest few are 561, 1105, 1729, 2465, 2821, and 6601. In testing primality of very large 
; numbers chosen at random, the chance of stumbling upon a value that fools the Fermat test is 
; less than the chance that cosmic radiation will cause the computer to make an error in carrying 
; out a ``correct'' algorithm. Considering an algorithm to be inadequate for the first reason 
; but not for the second illustrates the difference between mathematics and engineering.